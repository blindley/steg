
#include <array>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <string>
#include <span>
#include <cassert>
#include <bit>
#include <random>

#include "declarations.h"

// Converts a single byte to gray code
//
// The reason for this operation is explained here: http://datahide.org/BPCSe/pbc-vs-cgc-e.html
u8 binary_to_gray_code(u8 binary) {
    return (binary >> 1) ^ binary;
}

// Converts a gray code byte back to plain binary
u8 gray_code_to_binary(u8 gray_code) {
    u8 temp = gray_code ^ (gray_code >> 4);
    temp ^= (temp >> 2);
    temp ^= (temp >> 1);
    return temp;
}

// Converts an array of bytes to gray code
void binary_to_gray_code_inplace(std::vector<u8>& vec) {
    std::transform(vec.begin(), vec.end(), vec.begin(), binary_to_gray_code);
}

// Converts an array of gray code bytes back to plain binary
void gray_code_to_binary_inplace(std::vector<u8>& vec) {
    std::transform(vec.begin(), vec.end(), vec.begin(), gray_code_to_binary);
}

// Generates the magic chunks
//
// MAGIC_14 is a const array consisting of 14 random bytes generated from random.org These 14 bytes
// are split into 2 groups of 7, and then an 8th byte is attached to each. These appended bytes
// actually contain 4 numbers, taking 4 bits each, indicating how many bitplanes of each of the
// channels is used for hiding the message.
//
// The two 8 byte groups become the magic chunks, which are placed near the front of the message.
// Because these chunks contain 14 randomly generated bytes, or 112 bits, the probability of these
// bytes appearing by chance in an image is astronomically low. So the presence of these magic
// chunks does two things. First, it identifies the image as almost certainly containing a hidden
// message which was inserted by this program. And second, it allows the extraction algorithm
// determine which bitplanes were used for hiding the message.
std::array<DataChunk, 2> generate_magic_chunks(u8 rmax, u8 gmax, u8 bmax, u8 amax) {
    std::array<DataChunk, 2> chunks;
    std::memcpy(chunks[0].bytes, MAGIC_14, 7);
    std::memcpy(chunks[1].bytes, MAGIC_14 + 7, 7);
    chunks[0].bytes[7] = (rmax << 4) | gmax;
    chunks[1].bytes[7] = (bmax << 4) | amax;

    return chunks;
}

// Check if this data chunk is one of the magic chunks
bool is_magic(DataChunk const& chunk, size_t magic_chunk_index) {
    if (magic_chunk_index < 0 || magic_chunk_index > 1) {
        // note that any time we throw a logic_error, that means there is a bug in the code that
        // needs to be fixed, whereas a runtime_error occurs when the program runs into an error
        // based on input, such as incorrect parameters on the command line, or failure in reading a
        // file
        auto err = "invalid magic chunk index, you shouldn't be here";
        throw std::logic_error(err);
    }
    auto magic_bytes = MAGIC_14 + magic_chunk_index * 7;
    return std::memcmp(chunk.bytes, magic_bytes, 7) == 0;
}

// Returns an array containing which specific bitplanes to use, and in what order
//
// The resulting array acts as a lookup table. bitplane_priority[0] will be the first bitplane that
// should be used. A loop similar to the following will appear in several functions in this file
//
//     auto bitplane_priority = generate_bitplane_priority(rmax, gmax, bmax, amax);
//     for (size_t i = 0; i < bitplane_priority.size(); i++) {
//         size_t bitplane_index = bitplane_priority[i];
//         ...
//     }
//
// That will iterate over the usable bitplanes, as determined by rmax, gmax, bmax and amax, which
// are provided by the user during hiding, or extracted from the image during extraction.
//
// The bitplanes are numbered, as far as this program is concerned, as follows,
// - 0-7   = Red (0 is MSB, 7 is LSB)
// - 8-15  = Green
// - 16-23 = Blue
// - 24-31 = Alpha
//
// The default order of the bitplanes, if all bitplanes are allowed to be used, is to start with red
// LSB (7), then proceed to the LSB of green (15), blue (23) and alpha (31). We keep rotating
// through rgba like that, going up and up to more significant bitplanes. Any one of the channels
// can be capped with a max number of bitplanes, where 0 means no bitplanes of that channel are
// used, and 8 means all of them are used. The least significant bitplanes of any particular channel
// are always used first. So an rmax value of 6, for example, would mean that the 2 most significant
// bitplanes of the red channel are not used.
std::vector<size_t> generate_bitplane_priority(u8 rmax, u8 gmax, u8 bmax, u8 amax) {
    std::vector<size_t> bitplane_priority;

    for (size_t i = 0; i < 8; i++) {
        if (i < rmax)
            bitplane_priority.push_back(7 - i);
        if (i < gmax)
            bitplane_priority.push_back(15 - i);
        if (i < bmax)
            bitplane_priority.push_back(23 - i);
        if (i < amax)
            bitplane_priority.push_back(31 - i);
    }

    return bitplane_priority;
}

// Common code for chunkify and de_chunkify
//
// chunkify and de_chunkify require almost the exact same code structure, with four nested for
// loops. There is a slight difference in setup, and a slight difference in the innermost portion of
// the nested loops. In order to keep them in sync and not repeat the same code twice, this template
// function extracts the common bits, and takes callbacks to handle the differences
template<typename ImageT, typename InitT, typename TransferT>
void chunkify_common(ImageT& img, InitT init_op, TransferT transfer_op) {
    size_t chunks_in_width = img.width / 8;
    size_t chunks_in_height = img.height / 8;
    size_t chunks_per_bitplane = chunks_in_width * chunks_in_height;

    auto chunk_data_ptr = init_op(chunks_per_bitplane);
    size_t chunk_data_bit_index = 0;

    auto pixel_data_ptr = img.pixel_data.data();

    // Randomize the order by which we iterate through the chunks of each bitplane. Unlike the C
    // rand() function, the random number generators provided in the C++ <random> header are
    // guaranteed to be reproducible for any particular seed across all standard compliant
    // platforms. This is potentially a good place to introduce some encryption, by using the
    // password to modify the seed.
    u64 seed = img.width * 1000003 + img.height;
    std::mt19937_64 gen(seed);
    std::vector<size_t> chunk_priority;
    chunk_priority.resize(chunks_per_bitplane);
    for (size_t i = 0; i < chunks_per_bitplane; i++)
        chunk_priority[i] = i;

    for (size_t bp = 0; bp < 32; bp++) {
        size_t bitplane_index = bp;

        // We shuffle the chunk priority for every bitplane, so the order is different for each one.
        // This probably doesn't do anything to help with detectability, but perhaps it makes
        // extraction harder.
        std::shuffle(chunk_priority.begin(), chunk_priority.end(), gen);

        for (size_t ci = 0; ci < chunks_per_bitplane; ci++) {
            size_t chunk_index = chunk_priority[ci];
            size_t chunk_x_index = chunk_index % chunks_in_width;
            size_t chunk_y_index = chunk_index / chunks_in_width;

            for (size_t row_in_chunk = 0; row_in_chunk < 8; row_in_chunk++) {
                for (size_t col_in_chunk = 0; col_in_chunk < 8; col_in_chunk++) {
                    size_t pixel_x = chunk_x_index * 8 + col_in_chunk;
                    size_t pixel_y = chunk_y_index * 8 + row_in_chunk;
                    size_t pixel_index = pixel_y * img.width + pixel_x;
                    size_t byte_index = pixel_index * 4;
                    size_t pixel_data_bit_index = byte_index * 8 + bitplane_index;

                    transfer_op(pixel_data_ptr, pixel_data_bit_index,
                        chunk_data_ptr, chunk_data_bit_index);
                    ++chunk_data_bit_index;
                }
            }
        }
    }
}

// Returns an array of DataChunks from the bitplanes of the image
//
// A DataChunk is an 8x8 bit chunk of a single bitplane of the image. The chunks are pulled out from
// one bitplane at a time. The order in which the chunks are pulled out in each bitplane is
// randomized using a reproducible random number generator with a fixed seed. For images in which
// the width or height is not divisible by 8, the excess pixels on the right side or bottom are
// simply skipped over, so there is no problem in handling images of any size.
//
// This requires a lot of intricate work shuffling around bits. But this process is greatly
// simplified by the get_bit(...) and set_bit(...) functions, which essentially treat an array of
// bytes as an array of bits. This makes the process of copying bits about as simple as it is to
// copy bytes.
DataChunkArray chunkify(Image const& img) {
    DataChunkArray chunk_data;
    auto init_op = [&](size_t chunks_per_bitplane) -> u8* {
        // Allocate space for all 32 bitplanes of chunk data
        chunk_data.chunks.resize(chunks_per_bitplane * 32);
        return chunk_data.bytes_begin();
    };

    auto transfer_op = [](u8 const* pixel_data_ptr, size_t pixel_data_bit_index,
        u8* chunk_data_ptr, size_t chunk_data_bit_index)
    {
        // transfer one bit from the pixel data to the chunk data
        auto bit_value = get_bit(pixel_data_ptr, pixel_data_bit_index);
        set_bit(chunk_data_ptr, chunk_data_bit_index, bit_value);
    };

    // init_op and transfer_op are callback functions, which are called in chunkify_common. So no
    // work has actually been done so far in this function until we call chunkify_common
    chunkify_common(img, init_op, transfer_op);

    return chunk_data;
}

// Inserts an array of DataChunks back into an image.
//
// Simply reverses the process of chunkify(...), breaking the chunks apart into their component bits
// and placing the bits them back into the appropriate place in the image. The same random number
// generator with the same seed is used as was used in chunkify(...).
//
// The structure of the loops is identical to that of chunkify(...), with the only difference being
// which array we call get_bit(...) and set_bit(...) on.
void de_chunkify(Image& img, DataChunkArray const& chunk_data) {
    auto init_op = [&](size_t chunks_per_bitplane) {
        // nothing to allocate in this case, just return a pointer to the chunk data
        return chunk_data.bytes_begin();
    };

    auto transfer_op = [](u8* pixel_data_ptr, size_t pixel_data_bit_index,
        u8 const* chunk_data_ptr, size_t chunk_data_bit_index)
    {
        // transfer one bit from chunk data to pixel data, the opposite of what chunkify does
        auto bit_value = get_bit(chunk_data_ptr, chunk_data_bit_index);
        set_bit(pixel_data_ptr, pixel_data_bit_index, bit_value);
    };

    // As with chunkify, init_op and transfer_op are callback functions, which are called in
    // chunkify_common. So no work has actually been done so far in this function until we call
    // chunkify_common
    chunkify_common(img, init_op, transfer_op);
}

// Hides an already formatted message in a DataChunkArray returned by chunkify(...)
//
// Iterate over the chunks in order of bitplane priority (see generate_bitplane_priority(...)),
// checking their complexity against the threshold, and inserting the chunks from the formatted
// message at those locations. Note that the first two available chunks are used to store the
// magic chunks (see generate_magic_chunks(...))
void hide_formatted_message(HideStats& stats, float threshold,
    DataChunkArray& cover, DataChunkArray const& formatted_message,
    u8 rmax, u8 gmax, u8 bmax, u8 amax)
{
    auto bitplane_priority = generate_bitplane_priority(rmax, gmax, bmax, amax);

    size_t chunks_per_bitplane = cover.chunks.size() / 32;
    auto message_chunk_iter = formatted_message.begin();

    for (size_t bp = 0; bp < bitplane_priority.size(); bp++) {
        if (message_chunk_iter == formatted_message.end())
            break;

        size_t bitplane_index = bitplane_priority[bp];

        for (size_t ci = 0; ci < chunks_per_bitplane; ci++) {
            if (message_chunk_iter == formatted_message.end())
                break;

            size_t chunk_index = bitplane_index * chunks_per_bitplane + ci;
            auto& cover_chunk = cover.chunks[chunk_index];

            float complexity = cover_chunk.measure_complexity();
            if (complexity >= threshold) {
                stats.chunks_used_per_bitplane[bitplane_index]++;
                stats.chunks_used++;

                cover_chunk = *message_chunk_iter;
                ++message_chunk_iter;
            }
        }
    }

    // truncate to multiple of 8, because the extractor can only handle chunks in groups of 8
    stats.chunks_used = stats.chunks_used / 8 * 8;
    stats.message_bytes_hidden = stats.chunks_used / 8 * 63 - 23;
}

// Extract a hidden formatted message from a DataChunkArray
//
// Just reverses the process of hide_formatted_message(...)
DataChunkArray unhide_formatted_message(DataChunkArray const& cover)
{
    size_t chunks_per_bitplane = cover.chunks.size() / 32;

    // Look for magic chunks to determine which bitplanes were used
    DataChunk magic_chunks[2];
    size_t magic_chunk_index = 0;
    auto bitplane_priority = generate_bitplane_priority(8, 8, 8, 8);
    for (size_t bp = 0; bp < bitplane_priority.size(); bp++) {
        if (magic_chunk_index == 2) // if both magic chunks have bee found
            break;

        size_t bitplane_index = bitplane_priority[bp];
        for (size_t ci = 0; ci < chunks_per_bitplane; ci++) {
            if (magic_chunk_index == 2)
                break;

            size_t chunk_index = bitplane_index * chunks_per_bitplane + ci;
            auto& cover_chunk = cover.chunks[chunk_index];
            if (is_magic(cover_chunk, magic_chunk_index)) {
                magic_chunks[magic_chunk_index++] = cover_chunk;
            }
        }
    }

    if (magic_chunk_index != 2) {
        auto err = "magic number not found";
        throw std::runtime_error(err);
    }

    // The last byte of each magic chunk contains the bitplanes used per color channel
    u8 rmax = (magic_chunks[0].bytes[7] >> 4) & 0xF;
    u8 gmax = magic_chunks[0].bytes[7] & 0xF;
    u8 bmax = (magic_chunks[1].bytes[7] >> 4) & 0xF;
    u8 amax = magic_chunks[1].bytes[7] & 0xF;

    bitplane_priority = generate_bitplane_priority(rmax, gmax, bmax, amax);

    DataChunkArray formatted_message;

    for (size_t bp = 0; bp < bitplane_priority.size(); bp++) {
        size_t bitplane_index = bitplane_priority[bp];

        for (size_t ci = 0; ci < chunks_per_bitplane; ci++) {
            size_t chunk_index = bitplane_index * chunks_per_bitplane + ci;
            auto& cover_chunk = cover.chunks[chunk_index];
            auto complexity = cover_chunk.measure_complexity();
            // When extracting, we don't have to care about the specific threshold that was used in
            // hiding, because the hiding algorithm just conjugates all message chunks with
            // complexity < 0.5, changing them to be >= 0.5
            if (complexity >= 0.5) {
                formatted_message.chunks.push_back(cover_chunk);
            }
        }
    }

    return formatted_message;
}

// Alters any existing magic chunks
//
// Although the probability of a magic chunk occuring in an image by chance is astronomically low,
// there is one caveat that makes their occurance much more likely. If a user hides a message in an
// image, and then tries to hide a message again in the resulting stego image, the stego image
// (which becomes the cover image in this case) will already contain magic chunks. If the new
// message is hidden with a higher threshold, or using fewer bitplanes, then it's likely that these
// original magic chunks will occur before the new magic chunks that we insert. This will cause an
// issue on extracting, because the extraction algorithm will be reading the wrong magic chunks for
// determining the rmax, gmax, bmax and amax values. This function eliminates that possibility.
void alter_magic_chunks(DataChunkArray& chunk_data) {
    for (auto& chunk : chunk_data) {
        if (is_magic(chunk, 0) || is_magic(chunk, 1)) {
            chunk.bytes[0] ^= 0x80; // flip the first bit of the first byte
        }
    }
}

// Hides a message in an image
//
// This is the high level function that ties everything together for the hiding algorithm.
HideStats bpcs_hide_message(float threshold, Image& img, std::vector<u8> const& message,
    u8 rmax, u8 gmax, u8 bmax, u8 amax)
{
    HideStats stats = {};
    stats.message_size = message.size();
    stats.chunks_per_bitplane = (img.width / 8) * (img.height / 8);

    auto formatted_data = format_message(message, rmax, gmax, bmax, amax);
    binary_to_gray_code_inplace(img.pixel_data);
    auto chunk_data = chunkify(img);
    alter_magic_chunks(chunk_data);
    auto bitplane_priority = generate_bitplane_priority(rmax, gmax, bmax, amax);

    if (threshold < 0.0f) {
        threshold = calculate_max_threshold(formatted_data.chunks.size(), chunk_data,
            bitplane_priority);
    }
    stats.threshold = threshold;
    hide_formatted_message(stats, threshold, chunk_data, formatted_data,
        rmax, gmax, bmax, amax);

    stats.message_bytes_hidden = std::min(stats.message_bytes_hidden, message.size());

    de_chunkify(img, chunk_data);
    gray_code_to_binary_inplace(img.pixel_data);

    return stats;
}

// Extracts a message hidden in an image
//
// The high level function that ties everything together for the extracting algorithm.
std::vector<u8> bpcs_unhide_message(Image& img) {
    binary_to_gray_code_inplace(img.pixel_data);
    auto chunk_data = chunkify(img);
    auto formatted_data = unhide_formatted_message(chunk_data);
    auto message = unformat_message(formatted_data);
    return message;
}

// Given an image and a complexity threshold, determines the image's hiding capacity at that
// threshold.
//
// Simply makes a message that definitely won't fit, and tries to hide it. The hide function will
// report how many bytes were actually hidden. Probably not the most efficient way to do this,
// but it works, and re-uses the code I already have.
HideStats measure_capacity(float threshold, Image& img, u8 rmax, u8 gmax, u8 bmax, u8 amax) {
    std::vector<u8> message(img.pixel_data.size());
    return bpcs_hide_message(threshold, img, message, rmax, gmax, bmax, amax);
}

#ifdef STEG_TEST

#include <gtest/gtest.h>

size_t num_bits_diff(u8 a, u8 b) {
    return std::popcount((u8)(a ^ b));
}

TEST(bpcs, gray_code_conversions) {
    for (int i = 0; i <= 256; i++) {
        u8 a = i;
        u8 b = i + 1;
        u8 ga = binary_to_gray_code(a);
        u8 gb = binary_to_gray_code(b);
        size_t diff = num_bits_diff(ga, gb);
        ASSERT_EQ(diff, 1);
    }

    for (int i = 0; i < 256; i++) {
        u8 a = i;
        u8 ga = binary_to_gray_code(a);
        u8 ba = gray_code_to_binary(ga);
        ASSERT_EQ(a, ba);
    }
}

Image generate_random_image(size_t width, size_t height) {
    std::random_device rd;
    auto seed = rd();
    std::mt19937_64 gen(seed);
    Image img = {};
    img.width = width;
    img.height = height;
    img.pixel_data.resize(img.width * img.height * 4);
    for (size_t chunk_start_y = 0; chunk_start_y + 8 <= img.height; chunk_start_y += 8) {
        for (size_t chunk_start_x = 0; chunk_start_x + 8 <= img.width; chunk_start_x += 8) {
            float p = (float)rand() / (float)RAND_MAX;
            if (p < 0.5) {
                for (size_t y_off = 0; y_off < 8; y_off++) {
                    for (size_t x_off = 0; x_off < 8; x_off++) {
                        size_t pixel_data_offset = (chunk_start_y + y_off) * img.width * 4
                            + x_off * 4;
                        for (size_t i = 0; i < 4; i++) {
                            size_t offset = pixel_data_offset + i;
                            img.pixel_data[offset] = gen();
                        }
                    }
                }
            }
        }
    }

    return img;
}

TEST(bpcs, message_hiding) {
    std::random_device rd;
    auto seed = rd();
    std::mt19937_64 gen(seed);

    std::vector<u8> message;
    for (size_t i = 0; i < 511; i++) {
        message.push_back(gen());
    }

    auto img = generate_random_image(257, 135);
    auto img_original = img;

    bpcs_hide_message(-1.0f, img, message, 8, 8, 8, 8);
    auto extracted_message = bpcs_unhide_message(img);

    ASSERT_EQ(message, extracted_message);

    img = img_original;

    bpcs_hide_message(-1.0f, img, message, 7, 6, 5, 4);
    auto extracted_message2 = bpcs_unhide_message(img);

    ASSERT_EQ(message, extracted_message2);
}

TEST(bpcs, generate_bitplane_priority) {
    auto bitplane_priority = generate_bitplane_priority(0, 0, 0, 0);
    ASSERT_EQ(bitplane_priority.empty(), true);

    bitplane_priority = generate_bitplane_priority(8, 8, 8, 8);
    std::vector<size_t> expected_bitplane_priority = {
        7, 15, 23, 31, 6, 14, 22, 30,
        5, 13, 21, 29, 4, 12, 20, 28,
        3, 11, 19, 27, 2, 10, 18, 26,
        1, 9, 17, 25, 0, 8, 16, 24,
    };

    ASSERT_EQ(bitplane_priority, expected_bitplane_priority);

    expected_bitplane_priority = {
        7, 15, 23, 31,
           14, 22, 30,
               21, 29,
                   28,
    };
    bitplane_priority = generate_bitplane_priority(1, 2, 3, 4);

    ASSERT_EQ(bitplane_priority, expected_bitplane_priority);
}

#endif // STEG_TEST
